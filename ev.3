.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.35
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title ""<STANDARD INPUT>" 1"
.TH "<STANDARD INPUT>" 1 "2007-11-24" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
libev \- a high performance full\-featured event loop written in C
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  #include <ev.h>
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Libev is an event loop: you register interest in certain events (such as a
file descriptor being readable or a timeout occuring), and it will manage
these event sources and provide your program with events.
.PP
To do this, it must take more or less complete control over your process
(or thread) by executing the \fIevent loop\fR handler, and will then
communicate events via a callback mechanism.
.PP
You register interest in certain events by registering so-called \fIevent
watchers\fR, which are relatively small C structures you initialise with the
details of the event, and then hand it over to libev by \fIstarting\fR the
watcher.
.SH "FEATURES"
.IX Header "FEATURES"
Libev supports select, poll, the linux-specific epoll and the bsd-specific
kqueue mechanisms for file descriptor events, relative timers, absolute
timers with customised rescheduling, signal events, process status change
events (related to \s-1SIGCHLD\s0), and event watchers dealing with the event
loop mechanism itself (idle, prepare and check watchers). It also is quite
fast (see this benchmark comparing
it to libevent for example).
.SH "CONVENTIONS"
.IX Header "CONVENTIONS"
Libev is very configurable. In this manual the default configuration
will be described, which supports multiple event loops. For more info
about various configuration options please have a look at the file
\&\fI\s-1README\s0.embed\fR in the libev distribution. If libev was configured without
support for multiple event loops, then all functions taking an initial
argument of name \f(CW\*(C`loop\*(C'\fR (which is always of type \f(CW\*(C`struct ev_loop *\*(C'\fR)
will not have this argument.
.SH "TIME REPRESENTATION"
.IX Header "TIME REPRESENTATION"
Libev represents time as a single floating point number, representing the
(fractional) number of seconds since the (\s-1POSIX\s0) epoch (somewhere near
the beginning of 1970, details are complicated, don't ask). This type is
called \f(CW\*(C`ev_tstamp\*(C'\fR, which is what you should use too. It usually aliases
to the \f(CW\*(C`double\*(C'\fR type in C, and when you need to do any calculations on
it, you should treat it as such.
.SH "GLOBAL FUNCTIONS"
.IX Header "GLOBAL FUNCTIONS"
These functions can be called anytime, even before initialising the
library in any way.
.IP "ev_tstamp ev_time ()" 4
.IX Item "ev_tstamp ev_time ()"
Returns the current time as libev would use it. Please note that the
\&\f(CW\*(C`ev_now\*(C'\fR function is usually faster and also often returns the timestamp
you actually want to know.
.IP "int ev_version_major ()" 4
.IX Item "int ev_version_major ()"
.PD 0
.IP "int ev_version_minor ()" 4
.IX Item "int ev_version_minor ()"
.PD
You can find out the major and minor version numbers of the library
you linked against by calling the functions \f(CW\*(C`ev_version_major\*(C'\fR and
\&\f(CW\*(C`ev_version_minor\*(C'\fR. If you want, you can compare against the global
symbols \f(CW\*(C`EV_VERSION_MAJOR\*(C'\fR and \f(CW\*(C`EV_VERSION_MINOR\*(C'\fR, which specify the
version of the library your program was compiled against.
.Sp
Usually, it's a good idea to terminate if the major versions mismatch,
as this indicates an incompatible change.  Minor versions are usually
compatible to older versions, so a larger minor version alone is usually
not a problem.
.Sp
Example: make sure we haven't accidentally been linked against the wrong
version:
.Sp
.Vb 3
\&  assert (("libev version mismatch",
\&           ev_version_major () == EV_VERSION_MAJOR
\&           && ev_version_minor () >= EV_VERSION_MINOR));
.Ve
.IP "unsigned int ev_supported_backends ()" 4
.IX Item "unsigned int ev_supported_backends ()"
Return the set of all backends (i.e. their corresponding \f(CW\*(C`EV_BACKEND_*\*(C'\fR
value) compiled into this binary of libev (independent of their
availability on the system you are running on). See \f(CW\*(C`ev_default_loop\*(C'\fR for
a description of the set values.
.Sp
Example: make sure we have the epoll method, because yeah this is cool and
a must have and can we have a torrent of it please!!!11
.Sp
.Vb 2
\&  assert (("sorry, no epoll, no sex",
\&           ev_supported_backends () & EVBACKEND_EPOLL));
.Ve
.IP "unsigned int ev_recommended_backends ()" 4
.IX Item "unsigned int ev_recommended_backends ()"
Return the set of all backends compiled into this binary of libev and also
recommended for this platform. This set is often smaller than the one
returned by \f(CW\*(C`ev_supported_backends\*(C'\fR, as for example kqueue is broken on
most BSDs and will not be autodetected unless you explicitly request it
(assuming you know what you are doing). This is the set of backends that
libev will probe for if you specify no backends explicitly.
.IP "unsigned int ev_embeddable_backends ()" 4
.IX Item "unsigned int ev_embeddable_backends ()"
Returns the set of backends that are embeddable in other event loops. This
is the theoretical, all\-platform, value. To find which backends
might be supported on the current system, you would need to look at
\&\f(CW\*(C`ev_embeddable_backends () & ev_supported_backends ()\*(C'\fR, likewise for
recommended ones.
.Sp
See the description of \f(CW\*(C`ev_embed\*(C'\fR watchers for more info.
.IP "ev_set_allocator (void *(*cb)(void *ptr, long size))" 4
.IX Item "ev_set_allocator (void *(*cb)(void *ptr, long size))"
Sets the allocation function to use (the prototype is similar to the
realloc C function, the semantics are identical). It is used to allocate
and free memory (no surprises here). If it returns zero when memory
needs to be allocated, the library might abort or take some potentially
destructive action. The default is your system realloc function.
.Sp
You could override this function in high-availability programs to, say,
free some memory if it cannot allocate memory, to use a special allocator,
or even to sleep a while and retry until some memory is available.
.Sp
Example: replace the libev allocator with one that waits a bit and then
retries: better than mine).
.Sp
.Vb 6
\&   static void *
\&   persistent_realloc (void *ptr, long size)
\&   {
\&     for (;;)
\&       {
\&         void *newptr = realloc (ptr, size);
.Ve
.Sp
.Vb 2
\&         if (newptr)
\&           return newptr;
.Ve
.Sp
.Vb 3
\&         sleep (60);
\&       }
\&   }
.Ve
.Sp
.Vb 2
\&   ...
\&   ev_set_allocator (persistent_realloc);
.Ve
.IP "ev_set_syserr_cb (void (*cb)(const char *msg));" 4
.IX Item "ev_set_syserr_cb (void (*cb)(const char *msg));"
Set the callback function to call on a retryable syscall error (such
as failed select, poll, epoll_wait). The message is a printable string
indicating the system call or subsystem causing the problem. If this
callback is set, then libev will expect it to remedy the sitution, no
matter what, when it returns. That is, libev will generally retry the
requested operation, or, if the condition doesn't go away, do bad stuff
(such as abort).
.Sp
Example: do the same thing as libev does internally:
.Sp
.Vb 6
\&   static void
\&   fatal_error (const char *msg)
\&   {
\&     perror (msg);
\&     abort ();
\&   }
.Ve
.Sp
.Vb 2
\&   ...
\&   ev_set_syserr_cb (fatal_error);
.Ve
.SH "FUNCTIONS CONTROLLING THE EVENT LOOP"
.IX Header "FUNCTIONS CONTROLLING THE EVENT LOOP"
An event loop is described by a \f(CW\*(C`struct ev_loop *\*(C'\fR. The library knows two
types of such loops, the \fIdefault\fR loop, which supports signals and child
events, and dynamically created loops which do not.
.PP
If you use threads, a common model is to run the default event loop
in your main thread (or in a separate thread) and for each thread you
create, you also create another event loop. Libev itself does no locking
whatsoever, so if you mix calls to the same event loop in different
threads, make sure you lock (this is usually a bad idea, though, even if
done correctly, because it's hideous and inefficient).
.IP "struct ev_loop *ev_default_loop (unsigned int flags)" 4
.IX Item "struct ev_loop *ev_default_loop (unsigned int flags)"
This will initialise the default event loop if it hasn't been initialised
yet and return it. If the default loop could not be initialised, returns
false. If it already was initialised it simply returns it (and ignores the
flags. If that is troubling you, check \f(CW\*(C`ev_backend ()\*(C'\fR afterwards).
.Sp
If you don't know what event loop to use, use the one returned from this
function.
.Sp
The flags argument can be used to specify special behaviour or specific
backends to use, and is usually specified as \f(CW0\fR (or \f(CW\*(C`EVFLAG_AUTO\*(C'\fR).
.Sp
The following flags are supported:
.RS 4
.ie n .IP """EVFLAG_AUTO""" 4
.el .IP "\f(CWEVFLAG_AUTO\fR" 4
.IX Item "EVFLAG_AUTO"
The default flags value. Use this if you have no clue (it's the right
thing, believe me).
.ie n .IP """EVFLAG_NOENV""" 4
.el .IP "\f(CWEVFLAG_NOENV\fR" 4
.IX Item "EVFLAG_NOENV"
If this flag bit is ored into the flag value (or the program runs setuid
or setgid) then libev will \fInot\fR look at the environment variable
\&\f(CW\*(C`LIBEV_FLAGS\*(C'\fR. Otherwise (the default), this environment variable will
override the flags completely if it is found in the environment. This is
useful to try out specific backends to test their performance, or to work
around bugs.
.ie n .IP """EVBACKEND_SELECT""  (value 1, portable select backend)" 4
.el .IP "\f(CWEVBACKEND_SELECT\fR  (value 1, portable select backend)" 4
.IX Item "EVBACKEND_SELECT  (value 1, portable select backend)"
This is your standard \fIselect\fR\|(2) backend. Not \fIcompletely\fR standard, as
libev tries to roll its own fd_set with no limits on the number of fds,
but if that fails, expect a fairly low limit on the number of fds when
using this backend. It doesn't scale too well (O(highest_fd)), but its usually
the fastest backend for a low number of fds.
.ie n .IP """EVBACKEND_POLL""    (value 2, poll backend, available everywhere except on windows)" 4
.el .IP "\f(CWEVBACKEND_POLL\fR    (value 2, poll backend, available everywhere except on windows)" 4
.IX Item "EVBACKEND_POLL    (value 2, poll backend, available everywhere except on windows)"
And this is your standard \fIpoll\fR\|(2) backend. It's more complicated than
select, but handles sparse fds better and has no artificial limit on the
number of fds you can use (except it will slow down considerably with a
lot of inactive fds). It scales similarly to select, i.e. O(total_fds).
.ie n .IP """EVBACKEND_EPOLL""   (value 4, Linux)" 4
.el .IP "\f(CWEVBACKEND_EPOLL\fR   (value 4, Linux)" 4
.IX Item "EVBACKEND_EPOLL   (value 4, Linux)"
For few fds, this backend is a bit little slower than poll and select,
but it scales phenomenally better. While poll and select usually scale like
O(total_fds) where n is the total number of fds (or the highest fd), epoll scales
either O(1) or O(active_fds).
.Sp
While stopping and starting an I/O watcher in the same iteration will
result in some caching, there is still a syscall per such incident
(because the fd could point to a different file description now), so its
best to avoid that. Also, \fIdup()\fRed file descriptors might not work very
well if you register events for both fds.
.Sp
Please note that epoll sometimes generates spurious notifications, so you
need to use non-blocking I/O or other means to avoid blocking when no data
(or space) is available.
.ie n .IP """EVBACKEND_KQUEUE""  (value 8, most \s-1BSD\s0 clones)" 4
.el .IP "\f(CWEVBACKEND_KQUEUE\fR  (value 8, most \s-1BSD\s0 clones)" 4
.IX Item "EVBACKEND_KQUEUE  (value 8, most BSD clones)"
Kqueue deserves special mention, as at the time of this writing, it
was broken on all BSDs except NetBSD (usually it doesn't work with
anything but sockets and pipes, except on Darwin, where of course its
completely useless). For this reason its not being \*(L"autodetected\*(R"
unless you explicitly specify it explicitly in the flags (i.e. using
\&\f(CW\*(C`EVBACKEND_KQUEUE\*(C'\fR).
.Sp
It scales in the same way as the epoll backend, but the interface to the
kernel is more efficient (which says nothing about its actual speed, of
course). While starting and stopping an I/O watcher does not cause an
extra syscall as with epoll, it still adds up to four event changes per
incident, so its best to avoid that.
.ie n .IP """EVBACKEND_DEVPOLL"" (value 16, Solaris 8)" 4
.el .IP "\f(CWEVBACKEND_DEVPOLL\fR (value 16, Solaris 8)" 4
.IX Item "EVBACKEND_DEVPOLL (value 16, Solaris 8)"
This is not implemented yet (and might never be).
.ie n .IP """EVBACKEND_PORT""    (value 32, Solaris 10)" 4
.el .IP "\f(CWEVBACKEND_PORT\fR    (value 32, Solaris 10)" 4
.IX Item "EVBACKEND_PORT    (value 32, Solaris 10)"
This uses the Solaris 10 port mechanism. As with everything on Solaris,
it's really slow, but it still scales very well (O(active_fds)).
.Sp
Please note that solaris ports can result in a lot of spurious
notifications, so you need to use non-blocking I/O or other means to avoid
blocking when no data (or space) is available.
.ie n .IP """EVBACKEND_ALL""" 4
.el .IP "\f(CWEVBACKEND_ALL\fR" 4
.IX Item "EVBACKEND_ALL"
Try all backends (even potentially broken ones that wouldn't be tried
with \f(CW\*(C`EVFLAG_AUTO\*(C'\fR). Since this is a mask, you can do stuff such as
\&\f(CW\*(C`EVBACKEND_ALL & ~EVBACKEND_KQUEUE\*(C'\fR.
.RE
.RS 4
.Sp
If one or more of these are ored into the flags value, then only these
backends will be tried (in the reverse order as given here). If none are
specified, most compiled-in backend will be tried, usually in reverse
order of their flag values :)
.Sp
The most typical usage is like this:
.Sp
.Vb 2
\&  if (!ev_default_loop (0))
\&    fatal ("could not initialise libev, bad $LIBEV_FLAGS in environment?");
.Ve
.Sp
Restrict libev to the select and poll backends, and do not allow
environment settings to be taken into account:
.Sp
.Vb 1
\&  ev_default_loop (EVBACKEND_POLL | EVBACKEND_SELECT | EVFLAG_NOENV);
.Ve
.Sp
Use whatever libev has to offer, but make sure that kqueue is used if
available (warning, breaks stuff, best use only with your own private
event loop and only if you know the \s-1OS\s0 supports your types of fds):
.Sp
.Vb 1
\&  ev_default_loop (ev_recommended_backends () | EVBACKEND_KQUEUE);
.Ve
.RE
.IP "struct ev_loop *ev_loop_new (unsigned int flags)" 4
.IX Item "struct ev_loop *ev_loop_new (unsigned int flags)"
Similar to \f(CW\*(C`ev_default_loop\*(C'\fR, but always creates a new event loop that is
always distinct from the default loop. Unlike the default loop, it cannot
handle signal and child watchers, and attempts to do so will be greeted by
undefined behaviour (or a failed assertion if assertions are enabled).
.Sp
Example: try to create a event loop that uses epoll and nothing else.
.Sp
.Vb 3
\&  struct ev_loop *epoller = ev_loop_new (EVBACKEND_EPOLL | EVFLAG_NOENV);
\&  if (!epoller)
\&    fatal ("no epoll found here, maybe it hides under your chair");
.Ve
.IP "ev_default_destroy ()" 4
.IX Item "ev_default_destroy ()"
Destroys the default loop again (frees all memory and kernel state
etc.). None of the active event watchers will be stopped in the normal
sense, so e.g. \f(CW\*(C`ev_is_active\*(C'\fR might still return true. It is your
responsibility to either stop all watchers cleanly yoursef \fIbefore\fR
calling this function, or cope with the fact afterwards (which is usually
the easiest thing, youc na just ignore the watchers and/or \f(CW\*(C`free ()\*(C'\fR them
for example).
.IP "ev_loop_destroy (loop)" 4
.IX Item "ev_loop_destroy (loop)"
Like \f(CW\*(C`ev_default_destroy\*(C'\fR, but destroys an event loop created by an
earlier call to \f(CW\*(C`ev_loop_new\*(C'\fR.
.IP "ev_default_fork ()" 4
.IX Item "ev_default_fork ()"
This function reinitialises the kernel state for backends that have
one. Despite the name, you can call it anytime, but it makes most sense
after forking, in either the parent or child process (or both, but that
again makes little sense).
.Sp
You \fImust\fR call this function in the child process after forking if and
only if you want to use the event library in both processes. If you just
fork+exec, you don't have to call it.
.Sp
The function itself is quite fast and it's usually not a problem to call
it just in case after a fork. To make this easy, the function will fit in
quite nicely into a call to \f(CW\*(C`pthread_atfork\*(C'\fR:
.Sp
.Vb 1
\&    pthread_atfork (0, 0, ev_default_fork);
.Ve
.Sp
At the moment, \f(CW\*(C`EVBACKEND_SELECT\*(C'\fR and \f(CW\*(C`EVBACKEND_POLL\*(C'\fR are safe to use
without calling this function, so if you force one of those backends you
do not need to care.
.IP "ev_loop_fork (loop)" 4
.IX Item "ev_loop_fork (loop)"
Like \f(CW\*(C`ev_default_fork\*(C'\fR, but acts on an event loop created by
\&\f(CW\*(C`ev_loop_new\*(C'\fR. Yes, you have to call this on every allocated event loop
after fork, and how you do this is entirely your own problem.
.IP "unsigned int ev_backend (loop)" 4
.IX Item "unsigned int ev_backend (loop)"
Returns one of the \f(CW\*(C`EVBACKEND_*\*(C'\fR flags indicating the event backend in
use.
.IP "ev_tstamp ev_now (loop)" 4
.IX Item "ev_tstamp ev_now (loop)"
Returns the current \*(L"event loop time\*(R", which is the time the event loop
received events and started processing them. This timestamp does not
change as long as callbacks are being processed, and this is also the base
time used for relative timers. You can treat it as the timestamp of the
event occuring (or more correctly, libev finding out about it).
.IP "ev_loop (loop, int flags)" 4
.IX Item "ev_loop (loop, int flags)"
Finally, this is it, the event handler. This function usually is called
after you initialised all your watchers and you want to start handling
events.
.Sp
If the flags argument is specified as \f(CW0\fR, it will not return until
either no event watchers are active anymore or \f(CW\*(C`ev_unloop\*(C'\fR was called.
.Sp
Please note that an explicit \f(CW\*(C`ev_unloop\*(C'\fR is usually better than
relying on all watchers to be stopped when deciding when a program has
finished (especially in interactive programs), but having a program that
automatically loops as long as it has to and no longer by virtue of
relying on its watchers stopping correctly is a thing of beauty.
.Sp
A flags value of \f(CW\*(C`EVLOOP_NONBLOCK\*(C'\fR will look for new events, will handle
those events and any outstanding ones, but will not block your process in
case there are no events and will return after one iteration of the loop.
.Sp
A flags value of \f(CW\*(C`EVLOOP_ONESHOT\*(C'\fR will look for new events (waiting if
neccessary) and will handle those and any outstanding ones. It will block
your process until at least one new event arrives, and will return after
one iteration of the loop. This is useful if you are waiting for some
external event in conjunction with something not expressible using other
libev watchers. However, a pair of \f(CW\*(C`ev_prepare\*(C'\fR/\f(CW\*(C`ev_check\*(C'\fR watchers is
usually a better approach for this kind of thing.
.Sp
Here are the gory details of what \f(CW\*(C`ev_loop\*(C'\fR does:
.Sp
.Vb 18
\&   * If there are no active watchers (reference count is zero), return.
\&   - Queue prepare watchers and then call all outstanding watchers.
\&   - If we have been forked, recreate the kernel state.
\&   - Update the kernel state with all outstanding changes.
\&   - Update the "event loop time".
\&   - Calculate for how long to block.
\&   - Block the process, waiting for any events.
\&   - Queue all outstanding I/O (fd) events.
\&   - Update the "event loop time" and do time jump handling.
\&   - Queue all outstanding timers.
\&   - Queue all outstanding periodics.
\&   - If no events are pending now, queue all idle watchers.
\&   - Queue all check watchers.
\&   - Call all queued watchers in reverse order (i.e. check watchers first).
\&     Signals and child watchers are implemented as I/O watchers, and will
\&     be handled here by queueing them when their watcher gets executed.
\&   - If ev_unloop has been called or EVLOOP_ONESHOT or EVLOOP_NONBLOCK
\&     were used, return, otherwise continue with step *.
.Ve
.Sp
Example: queue some jobs and then loop until no events are outsanding
anymore.
.Sp
.Vb 4
\&   ... queue jobs here, make sure they register event watchers as long
\&   ... as they still have work to do (even an idle watcher will do..)
\&   ev_loop (my_loop, 0);
\&   ... jobs done. yeah!
.Ve
.IP "ev_unloop (loop, how)" 4
.IX Item "ev_unloop (loop, how)"
Can be used to make a call to \f(CW\*(C`ev_loop\*(C'\fR return early (but only after it
has processed all outstanding events). The \f(CW\*(C`how\*(C'\fR argument must be either
\&\f(CW\*(C`EVUNLOOP_ONE\*(C'\fR, which will make the innermost \f(CW\*(C`ev_loop\*(C'\fR call return, or
\&\f(CW\*(C`EVUNLOOP_ALL\*(C'\fR, which will make all nested \f(CW\*(C`ev_loop\*(C'\fR calls return.
.IP "ev_ref (loop)" 4
.IX Item "ev_ref (loop)"
.PD 0
.IP "ev_unref (loop)" 4
.IX Item "ev_unref (loop)"
.PD
Ref/unref can be used to add or remove a reference count on the event
loop: Every watcher keeps one reference, and as long as the reference
count is nonzero, \f(CW\*(C`ev_loop\*(C'\fR will not return on its own. If you have
a watcher you never unregister that should not keep \f(CW\*(C`ev_loop\*(C'\fR from
returning, \fIev_unref()\fR after starting, and \fIev_ref()\fR before stopping it. For
example, libev itself uses this for its internal signal pipe: It is not
visible to the libev user and should not keep \f(CW\*(C`ev_loop\*(C'\fR from exiting if
no event watchers registered by it are active. It is also an excellent
way to do this for generic recurring timers or from within third-party
libraries. Just remember to \fIunref after start\fR and \fIref before stop\fR.
.Sp
Example: create a signal watcher, but keep it from keeping \f(CW\*(C`ev_loop\*(C'\fR
running when nothing else is active.
.Sp
.Vb 4
\&  struct dv_signal exitsig;
\&  ev_signal_init (&exitsig, sig_cb, SIGINT);
\&  ev_signal_start (myloop, &exitsig);
\&  evf_unref (myloop);
.Ve
.Sp
Example: for some weird reason, unregister the above signal handler again.
.Sp
.Vb 2
\&  ev_ref (myloop);
\&  ev_signal_stop (myloop, &exitsig);
.Ve
.SH "ANATOMY OF A WATCHER"
.IX Header "ANATOMY OF A WATCHER"
A watcher is a structure that you create and register to record your
interest in some event. For instance, if you want to wait for \s-1STDIN\s0 to
become readable, you would create an \f(CW\*(C`ev_io\*(C'\fR watcher for that:
.PP
.Vb 5
\&  static void my_cb (struct ev_loop *loop, struct ev_io *w, int revents)
\&  {
\&    ev_io_stop (w);
\&    ev_unloop (loop, EVUNLOOP_ALL);
\&  }
.Ve
.PP
.Vb 6
\&  struct ev_loop *loop = ev_default_loop (0);
\&  struct ev_io stdin_watcher;
\&  ev_init (&stdin_watcher, my_cb);
\&  ev_io_set (&stdin_watcher, STDIN_FILENO, EV_READ);
\&  ev_io_start (loop, &stdin_watcher);
\&  ev_loop (loop, 0);
.Ve
.PP
As you can see, you are responsible for allocating the memory for your
watcher structures (and it is usually a bad idea to do this on the stack,
although this can sometimes be quite valid).
.PP
Each watcher structure must be initialised by a call to \f(CW\*(C`ev_init
(watcher *, callback)\*(C'\fR, which expects a callback to be provided. This
callback gets invoked each time the event occurs (or, in the case of io
watchers, each time the event loop detects that the file descriptor given
is readable and/or writable).
.PP
Each watcher type has its own \f(CW\*(C`ev_<type>_set (watcher *, ...)\*(C'\fR macro
with arguments specific to this watcher type. There is also a macro
to combine initialisation and setting in one call: \f(CW\*(C`ev_<type>_init
(watcher *, callback, ...)\*(C'\fR.
.PP
To make the watcher actually watch out for events, you have to start it
with a watcher-specific start function (\f(CW\*(C`ev_<type>_start (loop, watcher
*)\*(C'\fR), and you can stop watching for events at any time by calling the
corresponding stop function (\f(CW\*(C`ev_<type>_stop (loop, watcher *)\*(C'\fR.
.PP
As long as your watcher is active (has been started but not stopped) you
must not touch the values stored in it. Most specifically you must never
reinitialise it or call its \f(CW\*(C`set\*(C'\fR macro.
.PP
Each and every callback receives the event loop pointer as first, the
registered watcher structure as second, and a bitset of received events as
third argument.
.PP
The received events usually include a single bit per event type received
(you can receive multiple events at the same time). The possible bit masks
are:
.ie n .IP """EV_READ""" 4
.el .IP "\f(CWEV_READ\fR" 4
.IX Item "EV_READ"
.PD 0
.ie n .IP """EV_WRITE""" 4
.el .IP "\f(CWEV_WRITE\fR" 4
.IX Item "EV_WRITE"
.PD
The file descriptor in the \f(CW\*(C`ev_io\*(C'\fR watcher has become readable and/or
writable.
.ie n .IP """EV_TIMEOUT""" 4
.el .IP "\f(CWEV_TIMEOUT\fR" 4
.IX Item "EV_TIMEOUT"
The \f(CW\*(C`ev_timer\*(C'\fR watcher has timed out.
.ie n .IP """EV_PERIODIC""" 4
.el .IP "\f(CWEV_PERIODIC\fR" 4
.IX Item "EV_PERIODIC"
The \f(CW\*(C`ev_periodic\*(C'\fR watcher has timed out.
.ie n .IP """EV_SIGNAL""" 4
.el .IP "\f(CWEV_SIGNAL\fR" 4
.IX Item "EV_SIGNAL"
The signal specified in the \f(CW\*(C`ev_signal\*(C'\fR watcher has been received by a thread.
.ie n .IP """EV_CHILD""" 4
.el .IP "\f(CWEV_CHILD\fR" 4
.IX Item "EV_CHILD"
The pid specified in the \f(CW\*(C`ev_child\*(C'\fR watcher has received a status change.
.ie n .IP """EV_IDLE""" 4
.el .IP "\f(CWEV_IDLE\fR" 4
.IX Item "EV_IDLE"
The \f(CW\*(C`ev_idle\*(C'\fR watcher has determined that you have nothing better to do.
.ie n .IP """EV_PREPARE""" 4
.el .IP "\f(CWEV_PREPARE\fR" 4
.IX Item "EV_PREPARE"
.PD 0
.ie n .IP """EV_CHECK""" 4
.el .IP "\f(CWEV_CHECK\fR" 4
.IX Item "EV_CHECK"
.PD
All \f(CW\*(C`ev_prepare\*(C'\fR watchers are invoked just \fIbefore\fR \f(CW\*(C`ev_loop\*(C'\fR starts
to gather new events, and all \f(CW\*(C`ev_check\*(C'\fR watchers are invoked just after
\&\f(CW\*(C`ev_loop\*(C'\fR has gathered them, but before it invokes any callbacks for any
received events. Callbacks of both watcher types can start and stop as
many watchers as they want, and all of them will be taken into account
(for example, a \f(CW\*(C`ev_prepare\*(C'\fR watcher might start an idle watcher to keep
\&\f(CW\*(C`ev_loop\*(C'\fR from blocking).
.ie n .IP """EV_ERROR""" 4
.el .IP "\f(CWEV_ERROR\fR" 4
.IX Item "EV_ERROR"
An unspecified error has occured, the watcher has been stopped. This might
happen because the watcher could not be properly started because libev
ran out of memory, a file descriptor was found to be closed or any other
problem. You best act on it by reporting the problem and somehow coping
with the watcher being stopped.
.Sp
Libev will usually signal a few \*(L"dummy\*(R" events together with an error,
for example it might indicate that a fd is readable or writable, and if
your callbacks is well-written it can just attempt the operation and cope
with the error from \fIread()\fR or \fIwrite()\fR. This will not work in multithreaded
programs, though, so beware.
.Sh "\s-1GENERIC\s0 \s-1WATCHER\s0 \s-1FUNCTIONS\s0"
.IX Subsection "GENERIC WATCHER FUNCTIONS"
In the following description, \f(CW\*(C`TYPE\*(C'\fR stands for the watcher type,
e.g. \f(CW\*(C`timer\*(C'\fR for \f(CW\*(C`ev_timer\*(C'\fR watchers and \f(CW\*(C`io\*(C'\fR for \f(CW\*(C`ev_io\*(C'\fR watchers.
.ie n .IP """ev_init"" (ev_TYPE *watcher, callback)" 4
.el .IP "\f(CWev_init\fR (ev_TYPE *watcher, callback)" 4
.IX Item "ev_init (ev_TYPE *watcher, callback)"
This macro initialises the generic portion of a watcher. The contents
of the watcher object can be arbitrary (so \f(CW\*(C`malloc\*(C'\fR will do). Only
the generic parts of the watcher are initialised, you \fIneed\fR to call
the type-specific \f(CW\*(C`ev_TYPE_set\*(C'\fR macro afterwards to initialise the
type-specific parts. For each type there is also a \f(CW\*(C`ev_TYPE_init\*(C'\fR macro
which rolls both calls into one.
.Sp
You can reinitialise a watcher at any time as long as it has been stopped
(or never started) and there are no pending events outstanding.
.Sp
The callback is always of type \f(CW\*(C`void (*)(ev_loop *loop, ev_TYPE *watcher,
int revents)\*(C'\fR.
.ie n .IP """ev_TYPE_set"" (ev_TYPE *, [args])" 4
.el .IP "\f(CWev_TYPE_set\fR (ev_TYPE *, [args])" 4
.IX Item "ev_TYPE_set (ev_TYPE *, [args])"
This macro initialises the type-specific parts of a watcher. You need to
call \f(CW\*(C`ev_init\*(C'\fR at least once before you call this macro, but you can
call \f(CW\*(C`ev_TYPE_set\*(C'\fR any number of times. You must not, however, call this
macro on a watcher that is active (it can be pending, however, which is a
difference to the \f(CW\*(C`ev_init\*(C'\fR macro).
.Sp
Although some watcher types do not have type-specific arguments
(e.g. \f(CW\*(C`ev_prepare\*(C'\fR) you still need to call its \f(CW\*(C`set\*(C'\fR macro.
.ie n .IP """ev_TYPE_init"" (ev_TYPE *watcher, callback, [args])" 4
.el .IP "\f(CWev_TYPE_init\fR (ev_TYPE *watcher, callback, [args])" 4
.IX Item "ev_TYPE_init (ev_TYPE *watcher, callback, [args])"
This convinience macro rolls both \f(CW\*(C`ev_init\*(C'\fR and \f(CW\*(C`ev_TYPE_set\*(C'\fR macro
calls into a single call. This is the most convinient method to initialise
a watcher. The same limitations apply, of course.
.ie n .IP """ev_TYPE_start"" (loop *, ev_TYPE *watcher)" 4
.el .IP "\f(CWev_TYPE_start\fR (loop *, ev_TYPE *watcher)" 4
.IX Item "ev_TYPE_start (loop *, ev_TYPE *watcher)"
Starts (activates) the given watcher. Only active watchers will receive
events. If the watcher is already active nothing will happen.
.ie n .IP """ev_TYPE_stop"" (loop *, ev_TYPE *watcher)" 4
.el .IP "\f(CWev_TYPE_stop\fR (loop *, ev_TYPE *watcher)" 4
.IX Item "ev_TYPE_stop (loop *, ev_TYPE *watcher)"
Stops the given watcher again (if active) and clears the pending
status. It is possible that stopped watchers are pending (for example,
non-repeating timers are being stopped when they become pending), but
\&\f(CW\*(C`ev_TYPE_stop\*(C'\fR ensures that the watcher is neither active nor pending. If
you want to free or reuse the memory used by the watcher it is therefore a
good idea to always call its \f(CW\*(C`ev_TYPE_stop\*(C'\fR function.
.IP "bool ev_is_active (ev_TYPE *watcher)" 4
.IX Item "bool ev_is_active (ev_TYPE *watcher)"
Returns a true value iff the watcher is active (i.e. it has been started
and not yet been stopped). As long as a watcher is active you must not modify
it.
.IP "bool ev_is_pending (ev_TYPE *watcher)" 4
.IX Item "bool ev_is_pending (ev_TYPE *watcher)"
Returns a true value iff the watcher is pending, (i.e. it has outstanding
events but its callback has not yet been invoked). As long as a watcher
is pending (but not active) you must not call an init function on it (but
\&\f(CW\*(C`ev_TYPE_set\*(C'\fR is safe) and you must make sure the watcher is available to
libev (e.g. you cnanot \f(CW\*(C`free ()\*(C'\fR it).
.IP "callback = ev_cb (ev_TYPE *watcher)" 4
.IX Item "callback = ev_cb (ev_TYPE *watcher)"
Returns the callback currently set on the watcher.
.IP "ev_cb_set (ev_TYPE *watcher, callback)" 4
.IX Item "ev_cb_set (ev_TYPE *watcher, callback)"
Change the callback. You can change the callback at virtually any time
(modulo threads).
.Sh "\s-1ASSOCIATING\s0 \s-1CUSTOM\s0 \s-1DATA\s0 \s-1WITH\s0 A \s-1WATCHER\s0"
.IX Subsection "ASSOCIATING CUSTOM DATA WITH A WATCHER"
Each watcher has, by default, a member \f(CW\*(C`void *data\*(C'\fR that you can change
and read at any time, libev will completely ignore it. This can be used
to associate arbitrary data with your watcher. If you need more data and
don't want to allocate memory and store a pointer to it in that data
member, you can also \*(L"subclass\*(R" the watcher type and provide your own
data:
.PP
.Vb 7
\&  struct my_io
\&  {
\&    struct ev_io io;
\&    int otherfd;
\&    void *somedata;
\&    struct whatever *mostinteresting;
\&  }
.Ve
.PP
And since your callback will be called with a pointer to the watcher, you
can cast it back to your own type:
.PP
.Vb 5
\&  static void my_cb (struct ev_loop *loop, struct ev_io *w_, int revents)
\&  {
\&    struct my_io *w = (struct my_io *)w_;
\&    ...
\&  }
.Ve
.PP
More interesting and less C\-conformant ways of catsing your callback type
have been omitted....
.SH "WATCHER TYPES"
.IX Header "WATCHER TYPES"
This section describes each watcher in detail, but will not repeat
information given in the last section.
.ie n .Sh """ev_io"" \- is this file descriptor readable or writable?"
.el .Sh "\f(CWev_io\fP \- is this file descriptor readable or writable?"
.IX Subsection "ev_io - is this file descriptor readable or writable?"
I/O watchers check whether a file descriptor is readable or writable
in each iteration of the event loop, or, more precisely, when reading
would not block the process and writing would at least be able to write
some data. This behaviour is called level-triggering because you keep
receiving events as long as the condition persists. Remember you can stop
the watcher if you don't want to act on the event and neither want to
receive future events.
.PP
In general you can register as many read and/or write event watchers per
fd as you want (as long as you don't confuse yourself). Setting all file
descriptors to non-blocking mode is also usually a good idea (but not
required if you know what you are doing).
.PP
You have to be careful with dup'ed file descriptors, though. Some backends
(the linux epoll backend is a notable example) cannot handle dup'ed file
descriptors correctly if you register interest in two or more fds pointing
to the same underlying file/socket/etc. description (that is, they share
the same underlying \*(L"file open\*(R").
.PP
If you must do this, then force the use of a known-to-be-good backend
(at the time of this writing, this includes only \f(CW\*(C`EVBACKEND_SELECT\*(C'\fR and
\&\f(CW\*(C`EVBACKEND_POLL\*(C'\fR).
.PP
Another thing you have to watch out for is that it is quite easy to
receive \*(L"spurious\*(R" readyness notifications, that is your callback might
be called with \f(CW\*(C`EV_READ\*(C'\fR but a subsequent \f(CW\*(C`read\*(C'\fR(2) will actually block
because there is no data. Not only are some backends known to create a
lot of those (for example solaris ports), it is very easy to get into
this situation even with a relatively standard program structure. Thus
it is best to always use non-blocking I/O: An extra \f(CW\*(C`read\*(C'\fR(2) returning
\&\f(CW\*(C`EAGAIN\*(C'\fR is far preferable to a program hanging until some data arrives.
.PP
If you cannot run the fd in non-blocking mode (for example you should not
play around with an Xlib connection), then you have to seperately re-test
wether a file descriptor is really ready with a known-to-be good interface
such as poll (fortunately in our Xlib example, Xlib already does this on
its own, so its quite safe to use).
.IP "ev_io_init (ev_io *, callback, int fd, int events)" 4
.IX Item "ev_io_init (ev_io *, callback, int fd, int events)"
.PD 0
.IP "ev_io_set (ev_io *, int fd, int events)" 4
.IX Item "ev_io_set (ev_io *, int fd, int events)"
.PD
Configures an \f(CW\*(C`ev_io\*(C'\fR watcher. The \f(CW\*(C`fd\*(C'\fR is the file descriptor to
rceeive events for and events is either \f(CW\*(C`EV_READ\*(C'\fR, \f(CW\*(C`EV_WRITE\*(C'\fR or
\&\f(CW\*(C`EV_READ | EV_WRITE\*(C'\fR to receive the given events.
.PP
Example: call \f(CW\*(C`stdin_readable_cb\*(C'\fR when \s-1STDIN_FILENO\s0 has become, well
readable, but only once. Since it is likely line\-buffered, you could
attempt to read a whole line in the callback:
.PP
.Vb 6
\&  static void
\&  stdin_readable_cb (struct ev_loop *loop, struct ev_io *w, int revents)
\&  {
\&     ev_io_stop (loop, w);
\&    .. read from stdin here (or from w->fd) and haqndle any I/O errors
\&  }
.Ve
.PP
.Vb 6
\&  ...
\&  struct ev_loop *loop = ev_default_init (0);
\&  struct ev_io stdin_readable;
\&  ev_io_init (&stdin_readable, stdin_readable_cb, STDIN_FILENO, EV_READ);
\&  ev_io_start (loop, &stdin_readable);
\&  ev_loop (loop, 0);
.Ve
.ie n .Sh """ev_timer"" \- relative and optionally repeating timeouts"
.el .Sh "\f(CWev_timer\fP \- relative and optionally repeating timeouts"
.IX Subsection "ev_timer - relative and optionally repeating timeouts"
Timer watchers are simple relative timers that generate an event after a
given time, and optionally repeating in regular intervals after that.
.PP
The timers are based on real time, that is, if you register an event that
times out after an hour and you reset your system clock to last years
time, it will still time out after (roughly) and hour. \*(L"Roughly\*(R" because
detecting time jumps is hard, and some inaccuracies are unavoidable (the
monotonic clock option helps a lot here).
.PP
The relative timeouts are calculated relative to the \f(CW\*(C`ev_now ()\*(C'\fR
time. This is usually the right thing as this timestamp refers to the time
of the event triggering whatever timeout you are modifying/starting. If
you suspect event processing to be delayed and you \fIneed\fR to base the timeout
on the current time, use something like this to adjust for this:
.PP
.Vb 1
\&   ev_timer_set (&timer, after + ev_now () - ev_time (), 0.);
.Ve
.PP
The callback is guarenteed to be invoked only when its timeout has passed,
but if multiple timers become ready during the same loop iteration then
order of execution is undefined.
.IP "ev_timer_init (ev_timer *, callback, ev_tstamp after, ev_tstamp repeat)" 4
.IX Item "ev_timer_init (ev_timer *, callback, ev_tstamp after, ev_tstamp repeat)"
.PD 0
.IP "ev_timer_set (ev_timer *, ev_tstamp after, ev_tstamp repeat)" 4
.IX Item "ev_timer_set (ev_timer *, ev_tstamp after, ev_tstamp repeat)"
.PD
Configure the timer to trigger after \f(CW\*(C`after\*(C'\fR seconds. If \f(CW\*(C`repeat\*(C'\fR is
\&\f(CW0.\fR, then it will automatically be stopped. If it is positive, then the
timer will automatically be configured to trigger again \f(CW\*(C`repeat\*(C'\fR seconds
later, again, and again, until stopped manually.
.Sp
The timer itself will do a best-effort at avoiding drift, that is, if you
configure a timer to trigger every 10 seconds, then it will trigger at
exactly 10 second intervals. If, however, your program cannot keep up with
the timer (because it takes longer than those 10 seconds to do stuff) the
timer will not fire more than once per event loop iteration.
.IP "ev_timer_again (loop)" 4
.IX Item "ev_timer_again (loop)"
This will act as if the timer timed out and restart it again if it is
repeating. The exact semantics are:
.Sp
If the timer is started but nonrepeating, stop it.
.Sp
If the timer is repeating, either start it if necessary (with the repeat
value), or reset the running timer to the repeat value.
.Sp
This sounds a bit complicated, but here is a useful and typical
example: Imagine you have a tcp connection and you want a so-called idle
timeout, that is, you want to be called when there have been, say, 60
seconds of inactivity on the socket. The easiest way to do this is to
configure an \f(CW\*(C`ev_timer\*(C'\fR with after=repeat=60 and calling ev_timer_again each
time you successfully read or write some data. If you go into an idle
state where you do not expect data to travel on the socket, you can stop
the timer, and again will automatically restart it if need be.
.PP
Example: create a timer that fires after 60 seconds.
.PP
.Vb 5
\&  static void
\&  one_minute_cb (struct ev_loop *loop, struct ev_timer *w, int revents)
\&  {
\&    .. one minute over, w is actually stopped right here
\&  }
.Ve
.PP
.Vb 3
\&  struct ev_timer mytimer;
\&  ev_timer_init (&mytimer, one_minute_cb, 60., 0.);
\&  ev_timer_start (loop, &mytimer);
.Ve
.PP
Example: create a timeout timer that times out after 10 seconds of
inactivity.
.PP
.Vb 5
\&  static void
\&  timeout_cb (struct ev_loop *loop, struct ev_timer *w, int revents)
\&  {
\&    .. ten seconds without any activity
\&  }
.Ve
.PP
.Vb 4
\&  struct ev_timer mytimer;
\&  ev_timer_init (&mytimer, timeout_cb, 0., 10.); /* note, only repeat used */
\&  ev_timer_again (&mytimer); /* start timer */
\&  ev_loop (loop, 0);
.Ve
.PP
.Vb 3
\&  // and in some piece of code that gets executed on any "activity":
\&  // reset the timeout to start ticking again at 10 seconds
\&  ev_timer_again (&mytimer);
.Ve
.ie n .Sh """ev_periodic"" \- to cron or not to cron?"
.el .Sh "\f(CWev_periodic\fP \- to cron or not to cron?"
.IX Subsection "ev_periodic - to cron or not to cron?"
Periodic watchers are also timers of a kind, but they are very versatile
(and unfortunately a bit complex).
.PP
Unlike \f(CW\*(C`ev_timer\*(C'\fR's, they are not based on real time (or relative time)
but on wallclock time (absolute time). You can tell a periodic watcher
to trigger \*(L"at\*(R" some specific point in time. For example, if you tell a
periodic watcher to trigger in 10 seconds (by specifiying e.g. \f(CW\*(C`ev_now ()
+ 10.\*(C'\fR) and then reset your system clock to the last year, then it will
take a year to trigger the event (unlike an \f(CW\*(C`ev_timer\*(C'\fR, which would trigger
roughly 10 seconds later and of course not if you reset your system time
again).
.PP
They can also be used to implement vastly more complex timers, such as
triggering an event on eahc midnight, local time.
.PP
As with timers, the callback is guarenteed to be invoked only when the
time (\f(CW\*(C`at\*(C'\fR) has been passed, but if multiple periodic timers become ready
during the same loop iteration then order of execution is undefined.
.IP "ev_periodic_init (ev_periodic *, callback, ev_tstamp at, ev_tstamp interval, reschedule_cb)" 4
.IX Item "ev_periodic_init (ev_periodic *, callback, ev_tstamp at, ev_tstamp interval, reschedule_cb)"
.PD 0
.IP "ev_periodic_set (ev_periodic *, ev_tstamp after, ev_tstamp repeat, reschedule_cb)" 4
.IX Item "ev_periodic_set (ev_periodic *, ev_tstamp after, ev_tstamp repeat, reschedule_cb)"
.PD
Lots of arguments, lets sort it out... There are basically three modes of
operation, and we will explain them from simplest to complex:
.RS 4
.IP "* absolute timer (interval = reschedule_cb = 0)" 4
.IX Item "absolute timer (interval = reschedule_cb = 0)"
In this configuration the watcher triggers an event at the wallclock time
\&\f(CW\*(C`at\*(C'\fR and doesn't repeat. It will not adjust when a time jump occurs,
that is, if it is to be run at January 1st 2011 then it will run when the
system time reaches or surpasses this time.
.IP "* non-repeating interval timer (interval > 0, reschedule_cb = 0)" 4
.IX Item "non-repeating interval timer (interval > 0, reschedule_cb = 0)"
In this mode the watcher will always be scheduled to time out at the next
\&\f(CW\*(C`at + N * interval\*(C'\fR time (for some integer N) and then repeat, regardless
of any time jumps.
.Sp
This can be used to create timers that do not drift with respect to system
time:
.Sp
.Vb 1
\&   ev_periodic_set (&periodic, 0., 3600., 0);
.Ve
.Sp
This doesn't mean there will always be 3600 seconds in between triggers,
but only that the the callback will be called when the system time shows a
full hour (\s-1UTC\s0), or more correctly, when the system time is evenly divisible
by 3600.
.Sp
Another way to think about it (for the mathematically inclined) is that
\&\f(CW\*(C`ev_periodic\*(C'\fR will try to run the callback in this mode at the next possible
time where \f(CW\*(C`time = at (mod interval)\*(C'\fR, regardless of any time jumps.
.IP "* manual reschedule mode (reschedule_cb = callback)" 4
.IX Item "manual reschedule mode (reschedule_cb = callback)"
In this mode the values for \f(CW\*(C`interval\*(C'\fR and \f(CW\*(C`at\*(C'\fR are both being
ignored. Instead, each time the periodic watcher gets scheduled, the
reschedule callback will be called with the watcher as first, and the
current time as second argument.
.Sp
\&\s-1NOTE:\s0 \fIThis callback \s-1MUST\s0 \s-1NOT\s0 stop or destroy any periodic watcher,
ever, or make any event loop modifications\fR. If you need to stop it,
return \f(CW\*(C`now + 1e30\*(C'\fR (or so, fudge fudge) and stop it afterwards (e.g. by
starting a prepare watcher).
.Sp
Its prototype is \f(CW\*(C`ev_tstamp (*reschedule_cb)(struct ev_periodic *w,
ev_tstamp now)\*(C'\fR, e.g.:
.Sp
.Vb 4
\&   static ev_tstamp my_rescheduler (struct ev_periodic *w, ev_tstamp now)
\&   {
\&     return now + 60.;
\&   }
.Ve
.Sp
It must return the next time to trigger, based on the passed time value
(that is, the lowest time value larger than to the second argument). It
will usually be called just before the callback will be triggered, but
might be called at other times, too.
.Sp
\&\s-1NOTE:\s0 \fIThis callback must always return a time that is later than the
passed \f(CI\*(C`now\*(C'\fI value\fR. Not even \f(CW\*(C`now\*(C'\fR itself will do, it \fImust\fR be larger.
.Sp
This can be used to create very complex timers, such as a timer that
triggers on each midnight, local time. To do this, you would calculate the
next midnight after \f(CW\*(C`now\*(C'\fR and return the timestamp value for this. How
you do this is, again, up to you (but it is not trivial, which is the main
reason I omitted it as an example).
.RE
.RS 4
.RE
.IP "ev_periodic_again (loop, ev_periodic *)" 4
.IX Item "ev_periodic_again (loop, ev_periodic *)"
Simply stops and restarts the periodic watcher again. This is only useful
when you changed some parameters or the reschedule callback would return
a different time than the last time it was called (e.g. in a crond like
program when the crontabs have changed).
.PP
Example: call a callback every hour, or, more precisely, whenever the
system clock is divisible by 3600. The callback invocation times have
potentially a lot of jittering, but good long-term stability.
.PP
.Vb 5
\&  static void
\&  clock_cb (struct ev_loop *loop, struct ev_io *w, int revents)
\&  {
\&    ... its now a full hour (UTC, or TAI or whatever your clock follows)
\&  }
.Ve
.PP
.Vb 3
\&  struct ev_periodic hourly_tick;
\&  ev_periodic_init (&hourly_tick, clock_cb, 0., 3600., 0);
\&  ev_periodic_start (loop, &hourly_tick);
.Ve
.PP
Example: the same as above, but use a reschedule callback to do it:
.PP
.Vb 1
\&  #include <math.h>
.Ve
.PP
.Vb 5
\&  static ev_tstamp
\&  my_scheduler_cb (struct ev_periodic *w, ev_tstamp now)
\&  {
\&    return fmod (now, 3600.) + 3600.;
\&  }
.Ve
.PP
.Vb 1
\&  ev_periodic_init (&hourly_tick, clock_cb, 0., 0., my_scheduler_cb);
.Ve
.PP
Example: call a callback every hour, starting now:
.PP
.Vb 4
\&  struct ev_periodic hourly_tick;
\&  ev_periodic_init (&hourly_tick, clock_cb,
\&                    fmod (ev_now (loop), 3600.), 3600., 0);
\&  ev_periodic_start (loop, &hourly_tick);
.Ve
.ie n .Sh """ev_signal"" \- signal me when a signal gets signalled!"
.el .Sh "\f(CWev_signal\fP \- signal me when a signal gets signalled!"
.IX Subsection "ev_signal - signal me when a signal gets signalled!"
Signal watchers will trigger an event when the process receives a specific
signal one or more times. Even though signals are very asynchronous, libev
will try it's best to deliver signals synchronously, i.e. as part of the
normal event processing, like any other event.
.PP
You can configure as many watchers as you like per signal. Only when the
first watcher gets started will libev actually register a signal watcher
with the kernel (thus it coexists with your own signal handlers as long
as you don't register any with libev). Similarly, when the last signal
watcher for a signal is stopped libev will reset the signal handler to
\&\s-1SIG_DFL\s0 (regardless of what it was set to before).
.IP "ev_signal_init (ev_signal *, callback, int signum)" 4
.IX Item "ev_signal_init (ev_signal *, callback, int signum)"
.PD 0
.IP "ev_signal_set (ev_signal *, int signum)" 4
.IX Item "ev_signal_set (ev_signal *, int signum)"
.PD
Configures the watcher to trigger on the given signal number (usually one
of the \f(CW\*(C`SIGxxx\*(C'\fR constants).
.ie n .Sh """ev_child"" \- watch out for process status changes"
.el .Sh "\f(CWev_child\fP \- watch out for process status changes"
.IX Subsection "ev_child - watch out for process status changes"
Child watchers trigger when your process receives a \s-1SIGCHLD\s0 in response to
some child status changes (most typically when a child of yours dies).
.IP "ev_child_init (ev_child *, callback, int pid)" 4
.IX Item "ev_child_init (ev_child *, callback, int pid)"
.PD 0
.IP "ev_child_set (ev_child *, int pid)" 4
.IX Item "ev_child_set (ev_child *, int pid)"
.PD
Configures the watcher to wait for status changes of process \f(CW\*(C`pid\*(C'\fR (or
\&\fIany\fR process if \f(CW\*(C`pid\*(C'\fR is specified as \f(CW0\fR). The callback can look
at the \f(CW\*(C`rstatus\*(C'\fR member of the \f(CW\*(C`ev_child\*(C'\fR watcher structure to see
the status word (use the macros from \f(CW\*(C`sys/wait.h\*(C'\fR and see your systems
\&\f(CW\*(C`waitpid\*(C'\fR documentation). The \f(CW\*(C`rpid\*(C'\fR member contains the pid of the
process causing the status change.
.PP
Example: try to exit cleanly on \s-1SIGINT\s0 and \s-1SIGTERM\s0.
.PP
.Vb 5
\&  static void
\&  sigint_cb (struct ev_loop *loop, struct ev_signal *w, int revents)
\&  {
\&    ev_unloop (loop, EVUNLOOP_ALL);
\&  }
.Ve
.PP
.Vb 3
\&  struct ev_signal signal_watcher;
\&  ev_signal_init (&signal_watcher, sigint_cb, SIGINT);
\&  ev_signal_start (loop, &sigint_cb);
.Ve
.ie n .Sh """ev_idle"" \- when you've got nothing better to do..."
.el .Sh "\f(CWev_idle\fP \- when you've got nothing better to do..."
.IX Subsection "ev_idle - when you've got nothing better to do..."
Idle watchers trigger events when there are no other events are pending
(prepare, check and other idle watchers do not count). That is, as long
as your process is busy handling sockets or timeouts (or even signals,
imagine) it will not be triggered. But when your process is idle all idle
watchers are being called again and again, once per event loop iteration \-
until stopped, that is, or your process receives more events and becomes
busy.
.PP
The most noteworthy effect is that as long as any idle watchers are
active, the process will not block when waiting for new events.
.PP
Apart from keeping your process non-blocking (which is a useful
effect on its own sometimes), idle watchers are a good place to do
\&\*(L"pseudo\-background processing\*(R", or delay processing stuff to after the
event loop has handled all outstanding events.
.IP "ev_idle_init (ev_signal *, callback)" 4
.IX Item "ev_idle_init (ev_signal *, callback)"
Initialises and configures the idle watcher \- it has no parameters of any
kind. There is a \f(CW\*(C`ev_idle_set\*(C'\fR macro, but using it is utterly pointless,
believe me.
.PP
Example: dynamically allocate an \f(CW\*(C`ev_idle\*(C'\fR, start it, and in the
callback, free it. Alos, use no error checking, as usual.
.PP
.Vb 7
\&  static void
\&  idle_cb (struct ev_loop *loop, struct ev_idle *w, int revents)
\&  {
\&    free (w);
\&    // now do something you wanted to do when the program has
\&    // no longer asnything immediate to do.
\&  }
.Ve
.PP
.Vb 3
\&  struct ev_idle *idle_watcher = malloc (sizeof (struct ev_idle));
\&  ev_idle_init (idle_watcher, idle_cb);
\&  ev_idle_start (loop, idle_cb);
.Ve
.ie n .Sh """ev_prepare""\fP and \f(CW""ev_check"" \- customise your event loop!"
.el .Sh "\f(CWev_prepare\fP and \f(CWev_check\fP \- customise your event loop!"
.IX Subsection "ev_prepare and ev_check - customise your event loop!"
Prepare and check watchers are usually (but not always) used in tandem:
prepare watchers get invoked before the process blocks and check watchers
afterwards.
.PP
Their main purpose is to integrate other event mechanisms into libev and
their use is somewhat advanced. This could be used, for example, to track
variable changes, implement your own watchers, integrate net-snmp or a
coroutine library and lots more.
.PP
This is done by examining in each prepare call which file descriptors need
to be watched by the other library, registering \f(CW\*(C`ev_io\*(C'\fR watchers for
them and starting an \f(CW\*(C`ev_timer\*(C'\fR watcher for any timeouts (many libraries
provide just this functionality). Then, in the check watcher you check for
any events that occured (by checking the pending status of all watchers
and stopping them) and call back into the library. The I/O and timer
callbacks will never actually be called (but must be valid nevertheless,
because you never know, you know?).
.PP
As another example, the Perl Coro module uses these hooks to integrate
coroutines into libev programs, by yielding to other active coroutines
during each prepare and only letting the process block if no coroutines
are ready to run (it's actually more complicated: it only runs coroutines
with priority higher than or equal to the event loop and one coroutine
of lower priority, but only once, using idle watchers to keep the event
loop from blocking if lower-priority coroutines are active, thus mapping
low-priority coroutines to idle/background tasks).
.IP "ev_prepare_init (ev_prepare *, callback)" 4
.IX Item "ev_prepare_init (ev_prepare *, callback)"
.PD 0
.IP "ev_check_init (ev_check *, callback)" 4
.IX Item "ev_check_init (ev_check *, callback)"
.PD
Initialises and configures the prepare or check watcher \- they have no
parameters of any kind. There are \f(CW\*(C`ev_prepare_set\*(C'\fR and \f(CW\*(C`ev_check_set\*(C'\fR
macros, but using them is utterly, utterly and completely pointless.
.PP
Example: *TODO*.
.ie n .Sh """ev_embed"" \- when one backend isn't enough..."
.el .Sh "\f(CWev_embed\fP \- when one backend isn't enough..."
.IX Subsection "ev_embed - when one backend isn't enough..."
This is a rather advanced watcher type that lets you embed one event loop
into another (currently only \f(CW\*(C`ev_io\*(C'\fR events are supported in the embedded
loop, other types of watchers might be handled in a delayed or incorrect
fashion and must not be used).
.PP
There are primarily two reasons you would want that: work around bugs and
prioritise I/O.
.PP
As an example for a bug workaround, the kqueue backend might only support
sockets on some platform, so it is unusable as generic backend, but you
still want to make use of it because you have many sockets and it scales
so nicely. In this case, you would create a kqueue-based loop and embed it
into your default loop (which might use e.g. poll). Overall operation will
be a bit slower because first libev has to poll and then call kevent, but
at least you can use both at what they are best.
.PP
As for prioritising I/O: rarely you have the case where some fds have
to be watched and handled very quickly (with low latency), and even
priorities and idle watchers might have too much overhead. In this case
you would put all the high priority stuff in one loop and all the rest in
a second one, and embed the second one in the first.
.PP
As long as the watcher is active, the callback will be invoked every time
there might be events pending in the embedded loop. The callback must then
call \f(CW\*(C`ev_embed_sweep (mainloop, watcher)\*(C'\fR to make a single sweep and invoke
their callbacks (you could also start an idle watcher to give the embedded
loop strictly lower priority for example). You can also set the callback
to \f(CW0\fR, in which case the embed watcher will automatically execute the
embedded loop sweep.
.PP
As long as the watcher is started it will automatically handle events. The
callback will be invoked whenever some events have been handled. You can
set the callback to \f(CW0\fR to avoid having to specify one if you are not
interested in that.
.PP
Also, there have not currently been made special provisions for forking:
when you fork, you not only have to call \f(CW\*(C`ev_loop_fork\*(C'\fR on both loops,
but you will also have to stop and restart any \f(CW\*(C`ev_embed\*(C'\fR watchers
yourself.
.PP
Unfortunately, not all backends are embeddable, only the ones returned by
\&\f(CW\*(C`ev_embeddable_backends\*(C'\fR are, which, unfortunately, does not include any
portable one.
.PP
So when you want to use this feature you will always have to be prepared
that you cannot get an embeddable loop. The recommended way to get around
this is to have a separate variables for your embeddable loop, try to
create it, and if that fails, use the normal loop for everything:
.PP
.Vb 3
\&  struct ev_loop *loop_hi = ev_default_init (0);
\&  struct ev_loop *loop_lo = 0;
\&  struct ev_embed embed;
.Ve
.PP
.Vb 5
\&  // see if there is a chance of getting one that works
\&  // (remember that a flags value of 0 means autodetection)
\&  loop_lo = ev_embeddable_backends () & ev_recommended_backends ()
\&    ? ev_loop_new (ev_embeddable_backends () & ev_recommended_backends ())
\&    : 0;
.Ve
.PP
.Vb 8
\&  // if we got one, then embed it, otherwise default to loop_hi
\&  if (loop_lo)
\&    {
\&      ev_embed_init (&embed, 0, loop_lo);
\&      ev_embed_start (loop_hi, &embed);
\&    }
\&  else
\&    loop_lo = loop_hi;
.Ve
.IP "ev_embed_init (ev_embed *, callback, struct ev_loop *embedded_loop)" 4
.IX Item "ev_embed_init (ev_embed *, callback, struct ev_loop *embedded_loop)"
.PD 0
.IP "ev_embed_set (ev_embed *, callback, struct ev_loop *embedded_loop)" 4
.IX Item "ev_embed_set (ev_embed *, callback, struct ev_loop *embedded_loop)"
.PD
Configures the watcher to embed the given loop, which must be
embeddable. If the callback is \f(CW0\fR, then \f(CW\*(C`ev_embed_sweep\*(C'\fR will be
invoked automatically, otherwise it is the responsibility of the callback
to invoke it (it will continue to be called until the sweep has been done,
if you do not want thta, you need to temporarily stop the embed watcher).
.IP "ev_embed_sweep (loop, ev_embed *)" 4
.IX Item "ev_embed_sweep (loop, ev_embed *)"
Make a single, non-blocking sweep over the embedded loop. This works
similarly to \f(CW\*(C`ev_loop (embedded_loop, EVLOOP_NONBLOCK)\*(C'\fR, but in the most
apropriate way for embedded loops.
.SH "OTHER FUNCTIONS"
.IX Header "OTHER FUNCTIONS"
There are some other functions of possible interest. Described. Here. Now.
.IP "ev_once (loop, int fd, int events, ev_tstamp timeout, callback)" 4
.IX Item "ev_once (loop, int fd, int events, ev_tstamp timeout, callback)"
This function combines a simple timer and an I/O watcher, calls your
callback on whichever event happens first and automatically stop both
watchers. This is useful if you want to wait for a single event on an fd
or timeout without having to allocate/configure/start/stop/free one or
more watchers yourself.
.Sp
If \f(CW\*(C`fd\*(C'\fR is less than 0, then no I/O watcher will be started and events
is being ignored. Otherwise, an \f(CW\*(C`ev_io\*(C'\fR watcher for the given \f(CW\*(C`fd\*(C'\fR and
\&\f(CW\*(C`events\*(C'\fR set will be craeted and started.
.Sp
If \f(CW\*(C`timeout\*(C'\fR is less than 0, then no timeout watcher will be
started. Otherwise an \f(CW\*(C`ev_timer\*(C'\fR watcher with after = \f(CW\*(C`timeout\*(C'\fR (and
repeat = 0) will be started. While \f(CW0\fR is a valid timeout, it is of
dubious value.
.Sp
The callback has the type \f(CW\*(C`void (*cb)(int revents, void *arg)\*(C'\fR and gets
passed an \f(CW\*(C`revents\*(C'\fR set like normal event callbacks (a combination of
\&\f(CW\*(C`EV_ERROR\*(C'\fR, \f(CW\*(C`EV_READ\*(C'\fR, \f(CW\*(C`EV_WRITE\*(C'\fR or \f(CW\*(C`EV_TIMEOUT\*(C'\fR) and the \f(CW\*(C`arg\*(C'\fR
value passed to \f(CW\*(C`ev_once\*(C'\fR:
.Sp
.Vb 7
\&  static void stdin_ready (int revents, void *arg)
\&  {
\&    if (revents & EV_TIMEOUT)
\&      /* doh, nothing entered */;
\&    else if (revents & EV_READ)
\&      /* stdin might have data for us, joy! */;
\&  }
.Ve
.Sp
.Vb 1
\&  ev_once (STDIN_FILENO, EV_READ, 10., stdin_ready, 0);
.Ve
.IP "ev_feed_event (ev_loop *, watcher *, int revents)" 4
.IX Item "ev_feed_event (ev_loop *, watcher *, int revents)"
Feeds the given event set into the event loop, as if the specified event
had happened for the specified watcher (which must be a pointer to an
initialised but not necessarily started event watcher).
.IP "ev_feed_fd_event (ev_loop *, int fd, int revents)" 4
.IX Item "ev_feed_fd_event (ev_loop *, int fd, int revents)"
Feed an event on the given fd, as if a file descriptor backend detected
the given events it.
.IP "ev_feed_signal_event (ev_loop *loop, int signum)" 4
.IX Item "ev_feed_signal_event (ev_loop *loop, int signum)"
Feed an event as if the given signal occured (\f(CW\*(C`loop\*(C'\fR must be the default
loop!).
.SH "LIBEVENT EMULATION"
.IX Header "LIBEVENT EMULATION"
Libev offers a compatibility emulation layer for libevent. It cannot
emulate the internals of libevent, so here are some usage hints:
.IP "* Use it by including <event.h>, as usual." 4
.IX Item "Use it by including <event.h>, as usual."
.PD 0
.IP "* The following members are fully supported: ev_base, ev_callback, ev_arg, ev_fd, ev_res, ev_events." 4
.IX Item "The following members are fully supported: ev_base, ev_callback, ev_arg, ev_fd, ev_res, ev_events."
.IP "* Avoid using ev_flags and the EVLIST_*\-macros, while it is maintained by libev, it does not work exactly the same way as in libevent (consider it a private \s-1API\s0)." 4
.IX Item "Avoid using ev_flags and the EVLIST_*-macros, while it is maintained by libev, it does not work exactly the same way as in libevent (consider it a private API)."
.IP "* Priorities are not currently supported. Initialising priorities will fail and all watchers will have the same priority, even though there is an ev_pri field." 4
.IX Item "Priorities are not currently supported. Initialising priorities will fail and all watchers will have the same priority, even though there is an ev_pri field."
.IP "* Other members are not supported." 4
.IX Item "Other members are not supported."
.IP "* The libev emulation is \fInot\fR \s-1ABI\s0 compatible to libevent, you need to use the libev header file and library." 4
.IX Item "The libev emulation is not ABI compatible to libevent, you need to use the libev header file and library."
.PD
.SH "\*(C+ SUPPORT"
.IX Header " SUPPORT"
Libev comes with some simplistic wrapper classes for \*(C+ that mainly allow
you to use some convinience methods to start/stop watchers and also change
the callback model to a model using method callbacks on objects.
.PP
To use it,
.PP
.Vb 1
\&  #include <ev++.h>
.Ve
.PP
(it is not installed by default). This automatically includes \fIev.h\fR
and puts all of its definitions (many of them macros) into the global
namespace. All \*(C+ specific things are put into the \f(CW\*(C`ev\*(C'\fR namespace.
.PP
It should support all the same embedding options as \fIev.h\fR, most notably
\&\f(CW\*(C`EV_MULTIPLICITY\*(C'\fR.
.PP
Here is a list of things available in the \f(CW\*(C`ev\*(C'\fR namespace:
.ie n .IP """ev::READ""\fR, \f(CW""ev::WRITE"" etc." 4
.el .IP "\f(CWev::READ\fR, \f(CWev::WRITE\fR etc." 4
.IX Item "ev::READ, ev::WRITE etc."
These are just enum values with the same values as the \f(CW\*(C`EV_READ\*(C'\fR etc.
macros from \fIev.h\fR.
.ie n .IP """ev::tstamp""\fR, \f(CW""ev::now""" 4
.el .IP "\f(CWev::tstamp\fR, \f(CWev::now\fR" 4
.IX Item "ev::tstamp, ev::now"
Aliases to the same types/functions as with the \f(CW\*(C`ev_\*(C'\fR prefix.
.ie n .IP """ev::io""\fR, \f(CW""ev::timer""\fR, \f(CW""ev::periodic""\fR, \f(CW""ev::idle""\fR, \f(CW""ev::sig"" etc." 4
.el .IP "\f(CWev::io\fR, \f(CWev::timer\fR, \f(CWev::periodic\fR, \f(CWev::idle\fR, \f(CWev::sig\fR etc." 4
.IX Item "ev::io, ev::timer, ev::periodic, ev::idle, ev::sig etc."
For each \f(CW\*(C`ev_TYPE\*(C'\fR watcher in \fIev.h\fR there is a corresponding class of
the same name in the \f(CW\*(C`ev\*(C'\fR namespace, with the exception of \f(CW\*(C`ev_signal\*(C'\fR
which is called \f(CW\*(C`ev::sig\*(C'\fR to avoid clashes with the \f(CW\*(C`signal\*(C'\fR macro
defines by many implementations.
.Sp
All of those classes have these methods:
.RS 4
.IP "ev::TYPE::TYPE (object *, object::method *)" 4
.IX Item "ev::TYPE::TYPE (object *, object::method *)"
.PD 0
.IP "ev::TYPE::TYPE (object *, object::method *, struct ev_loop *)" 4
.IX Item "ev::TYPE::TYPE (object *, object::method *, struct ev_loop *)"
.IP "ev::TYPE::~TYPE" 4
.IX Item "ev::TYPE::~TYPE"
.PD
The constructor takes a pointer to an object and a method pointer to
the event handler callback to call in this class. The constructor calls
\&\f(CW\*(C`ev_init\*(C'\fR for you, which means you have to call the \f(CW\*(C`set\*(C'\fR method
before starting it. If you do not specify a loop then the constructor
automatically associates the default loop with this watcher.
.Sp
The destructor automatically stops the watcher if it is active.
.IP "w\->set (struct ev_loop *)" 4
.IX Item "w->set (struct ev_loop *)"
Associates a different \f(CW\*(C`struct ev_loop\*(C'\fR with this watcher. You can only
do this when the watcher is inactive (and not pending either).
.IP "w\->set ([args])" 4
.IX Item "w->set ([args])"
Basically the same as \f(CW\*(C`ev_TYPE_set\*(C'\fR, with the same args. Must be
called at least once.  Unlike the C counterpart, an active watcher gets
automatically stopped and restarted.
.IP "w\->start ()" 4
.IX Item "w->start ()"
Starts the watcher. Note that there is no \f(CW\*(C`loop\*(C'\fR argument as the
constructor already takes the loop.
.IP "w\->stop ()" 4
.IX Item "w->stop ()"
Stops the watcher if it is active. Again, no \f(CW\*(C`loop\*(C'\fR argument.
.ie n .IP "w\->again ()       ""ev::timer""\fR, \f(CW""ev::periodic"" only" 4
.el .IP "w\->again ()       \f(CWev::timer\fR, \f(CWev::periodic\fR only" 4
.IX Item "w->again ()       ev::timer, ev::periodic only"
For \f(CW\*(C`ev::timer\*(C'\fR and \f(CW\*(C`ev::periodic\*(C'\fR, this invokes the corresponding
\&\f(CW\*(C`ev_TYPE_again\*(C'\fR function.
.ie n .IP "w\->sweep ()       ""ev::embed"" only" 4
.el .IP "w\->sweep ()       \f(CWev::embed\fR only" 4
.IX Item "w->sweep ()       ev::embed only"
Invokes \f(CW\*(C`ev_embed_sweep\*(C'\fR.
.RE
.RS 4
.RE
.PP
Example: Define a class with an \s-1IO\s0 and idle watcher, start one of them in
the constructor.
.PP
.Vb 4
\&  class myclass
\&  {
\&    ev_io   io;   void io_cb   (ev::io   &w, int revents);
\&    ev_idle idle  void idle_cb (ev::idle &w, int revents);
.Ve
.PP
.Vb 2
\&    myclass ();
\&  }
.Ve
.PP
.Vb 6
\&  myclass::myclass (int fd)
\&  : io   (this, &myclass::io_cb),
\&    idle (this, &myclass::idle_cb)
\&  {
\&    io.start (fd, ev::READ);
\&  }
.Ve
.SH "EMBEDDING"
.IX Header "EMBEDDING"
Libev can (and often is) directly embedded into host
applications. Examples of applications that embed it include the Deliantra
Game Server, the \s-1EV\s0 perl module, the \s-1GNU\s0 Virtual Private Ethernet (gvpe)
and rxvt\-unicode.
.PP
The goal is to enable you to just copy the neecssary files into your
source directory without having to change even a single line in them, so
you can easily upgrade by simply copying (or having a checked-out copy of
libev somewhere in your source tree).
.Sh "\s-1FILESETS\s0"
.IX Subsection "FILESETS"
Depending on what features you need you need to include one or more sets of files
in your app.
.PP
\fI\s-1CORE\s0 \s-1EVENT\s0 \s-1LOOP\s0\fR
.IX Subsection "CORE EVENT LOOP"
.PP
To include only the libev core (all the \f(CW\*(C`ev_*\*(C'\fR functions), with manual
configuration (no autoconf):
.PP
.Vb 2
\&  #define EV_STANDALONE 1
\&  #include "ev.c"
.Ve
.PP
This will automatically include \fIev.h\fR, too, and should be done in a
single C source file only to provide the function implementations. To use
it, do the same for \fIev.h\fR in all files wishing to use this \s-1API\s0 (best
done by writing a wrapper around \fIev.h\fR that you can include instead and
where you can put other configuration options):
.PP
.Vb 2
\&  #define EV_STANDALONE 1
\&  #include "ev.h"
.Ve
.PP
Both header files and implementation files can be compiled with a \*(C+
compiler (at least, thats a stated goal, and breakage will be treated
as a bug).
.PP
You need the following files in your source tree, or in a directory
in your include path (e.g. in libev/ when using \-Ilibev):
.PP
.Vb 4
\&  ev.h
\&  ev.c
\&  ev_vars.h
\&  ev_wrap.h
.Ve
.PP
.Vb 1
\&  ev_win32.c      required on win32 platforms only
.Ve
.PP
.Vb 5
\&  ev_select.c     only when select backend is enabled (which is by default)
\&  ev_poll.c       only when poll backend is enabled (disabled by default)
\&  ev_epoll.c      only when the epoll backend is enabled (disabled by default)
\&  ev_kqueue.c     only when the kqueue backend is enabled (disabled by default)
\&  ev_port.c       only when the solaris port backend is enabled (disabled by default)
.Ve
.PP
\&\fIev.c\fR includes the backend files directly when enabled, so you only need
to compile this single file.
.PP
\fI\s-1LIBEVENT\s0 \s-1COMPATIBILITY\s0 \s-1API\s0\fR
.IX Subsection "LIBEVENT COMPATIBILITY API"
.PP
To include the libevent compatibility \s-1API\s0, also include:
.PP
.Vb 1
\&  #include "event.c"
.Ve
.PP
in the file including \fIev.c\fR, and:
.PP
.Vb 1
\&  #include "event.h"
.Ve
.PP
in the files that want to use the libevent \s-1API\s0. This also includes \fIev.h\fR.
.PP
You need the following additional files for this:
.PP
.Vb 2
\&  event.h
\&  event.c
.Ve
.PP
\fI\s-1AUTOCONF\s0 \s-1SUPPORT\s0\fR
.IX Subsection "AUTOCONF SUPPORT"
.PP
Instead of using \f(CW\*(C`EV_STANDALONE=1\*(C'\fR and providing your config in
whatever way you want, you can also \f(CW\*(C`m4_include([libev.m4])\*(C'\fR in your
\&\fIconfigure.ac\fR and leave \f(CW\*(C`EV_STANDALONE\*(C'\fR undefined. \fIev.c\fR will then
include \fIconfig.h\fR and configure itself accordingly.
.PP
For this of course you need the m4 file:
.PP
.Vb 1
\&  libev.m4
.Ve
.Sh "\s-1PREPROCESSOR\s0 \s-1SYMBOLS/MACROS\s0"
.IX Subsection "PREPROCESSOR SYMBOLS/MACROS"
Libev can be configured via a variety of preprocessor symbols you have to define
before including any of its files. The default is not to build for multiplicity
and only include the select backend.
.IP "\s-1EV_STANDALONE\s0" 4
.IX Item "EV_STANDALONE"
Must always be \f(CW1\fR if you do not use autoconf configuration, which
keeps libev from including \fIconfig.h\fR, and it also defines dummy
implementations for some libevent functions (such as logging, which is not
supported). It will also not define any of the structs usually found in
\&\fIevent.h\fR that are not directly supported by the libev core alone.
.IP "\s-1EV_USE_MONOTONIC\s0" 4
.IX Item "EV_USE_MONOTONIC"
If defined to be \f(CW1\fR, libev will try to detect the availability of the
monotonic clock option at both compiletime and runtime. Otherwise no use
of the monotonic clock option will be attempted. If you enable this, you
usually have to link against librt or something similar. Enabling it when
the functionality isn't available is safe, though, althoguh you have
to make sure you link against any libraries where the \f(CW\*(C`clock_gettime\*(C'\fR
function is hiding in (often \fI\-lrt\fR).
.IP "\s-1EV_USE_REALTIME\s0" 4
.IX Item "EV_USE_REALTIME"
If defined to be \f(CW1\fR, libev will try to detect the availability of the
realtime clock option at compiletime (and assume its availability at
runtime if successful). Otherwise no use of the realtime clock option will
be attempted. This effectively replaces \f(CW\*(C`gettimeofday\*(C'\fR by \f(CW\*(C`clock_get
(CLOCK_REALTIME, ...)\*(C'\fR and will not normally affect correctness. See tzhe note about libraries
in the description of \f(CW\*(C`EV_USE_MONOTONIC\*(C'\fR, though.
.IP "\s-1EV_USE_SELECT\s0" 4
.IX Item "EV_USE_SELECT"
If undefined or defined to be \f(CW1\fR, libev will compile in support for the
\&\f(CW\*(C`select\*(C'\fR(2) backend. No attempt at autodetection will be done: if no
other method takes over, select will be it. Otherwise the select backend
will not be compiled in.
.IP "\s-1EV_SELECT_USE_FD_SET\s0" 4
.IX Item "EV_SELECT_USE_FD_SET"
If defined to \f(CW1\fR, then the select backend will use the system \f(CW\*(C`fd_set\*(C'\fR
structure. This is useful if libev doesn't compile due to a missing
\&\f(CW\*(C`NFDBITS\*(C'\fR or \f(CW\*(C`fd_mask\*(C'\fR definition or it misguesses the bitset layout on
exotic systems. This usually limits the range of file descriptors to some
low limit such as 1024 or might have other limitations (winsocket only
allows 64 sockets). The \f(CW\*(C`FD_SETSIZE\*(C'\fR macro, set before compilation, might
influence the size of the \f(CW\*(C`fd_set\*(C'\fR used.
.IP "\s-1EV_SELECT_IS_WINSOCKET\s0" 4
.IX Item "EV_SELECT_IS_WINSOCKET"
When defined to \f(CW1\fR, the select backend will assume that
select/socket/connect etc. don't understand file descriptors but
wants osf handles on win32 (this is the case when the select to
be used is the winsock select). This means that it will call
\&\f(CW\*(C`_get_osfhandle\*(C'\fR on the fd to convert it to an \s-1OS\s0 handle. Otherwise,
it is assumed that all these functions actually work on fds, even
on win32. Should not be defined on non\-win32 platforms.
.IP "\s-1EV_USE_POLL\s0" 4
.IX Item "EV_USE_POLL"
If defined to be \f(CW1\fR, libev will compile in support for the \f(CW\*(C`poll\*(C'\fR(2)
backend. Otherwise it will be enabled on non\-win32 platforms. It
takes precedence over select.
.IP "\s-1EV_USE_EPOLL\s0" 4
.IX Item "EV_USE_EPOLL"
If defined to be \f(CW1\fR, libev will compile in support for the Linux
\&\f(CW\*(C`epoll\*(C'\fR(7) backend. Its availability will be detected at runtime,
otherwise another method will be used as fallback. This is the
preferred backend for GNU/Linux systems.
.IP "\s-1EV_USE_KQUEUE\s0" 4
.IX Item "EV_USE_KQUEUE"
If defined to be \f(CW1\fR, libev will compile in support for the \s-1BSD\s0 style
\&\f(CW\*(C`kqueue\*(C'\fR(2) backend. Its actual availability will be detected at runtime,
otherwise another method will be used as fallback. This is the preferred
backend for \s-1BSD\s0 and BSD-like systems, although on most BSDs kqueue only
supports some types of fds correctly (the only platform we found that
supports ptys for example was NetBSD), so kqueue might be compiled in, but
not be used unless explicitly requested. The best way to use it is to find
out whether kqueue supports your type of fd properly and use an embedded
kqueue loop.
.IP "\s-1EV_USE_PORT\s0" 4
.IX Item "EV_USE_PORT"
If defined to be \f(CW1\fR, libev will compile in support for the Solaris
10 port style backend. Its availability will be detected at runtime,
otherwise another method will be used as fallback. This is the preferred
backend for Solaris 10 systems.
.IP "\s-1EV_USE_DEVPOLL\s0" 4
.IX Item "EV_USE_DEVPOLL"
reserved for future expansion, works like the \s-1USE\s0 symbols above.
.IP "\s-1EV_H\s0" 4
.IX Item "EV_H"
The name of the \fIev.h\fR header file used to include it. The default if
undefined is \f(CW\*(C`<ev.h>\*(C'\fR in \fIevent.h\fR and \f(CW"ev.h"\fR in \fIev.c\fR. This
can be used to virtually rename the \fIev.h\fR header file in case of conflicts.
.IP "\s-1EV_CONFIG_H\s0" 4
.IX Item "EV_CONFIG_H"
If \f(CW\*(C`EV_STANDALONE\*(C'\fR isn't \f(CW1\fR, this variable can be used to override
\&\fIev.c\fR's idea of where to find the \fIconfig.h\fR file, similarly to
\&\f(CW\*(C`EV_H\*(C'\fR, above.
.IP "\s-1EV_EVENT_H\s0" 4
.IX Item "EV_EVENT_H"
Similarly to \f(CW\*(C`EV_H\*(C'\fR, this macro can be used to override \fIevent.c\fR's idea
of how the \fIevent.h\fR header can be found.
.IP "\s-1EV_PROTOTYPES\s0" 4
.IX Item "EV_PROTOTYPES"
If defined to be \f(CW0\fR, then \fIev.h\fR will not define any function
prototypes, but still define all the structs and other symbols. This is
occasionally useful if you want to provide your own wrapper functions
around libev functions.
.IP "\s-1EV_MULTIPLICITY\s0" 4
.IX Item "EV_MULTIPLICITY"
If undefined or defined to \f(CW1\fR, then all event-loop-specific functions
will have the \f(CW\*(C`struct ev_loop *\*(C'\fR as first argument, and you can create
additional independent event loops. Otherwise there will be no support
for multiple event loops and there is no first event loop pointer
argument. Instead, all functions act on the single default loop.
.IP "\s-1EV_PERIODICS\s0" 4
.IX Item "EV_PERIODICS"
If undefined or defined to be \f(CW1\fR, then periodic timers are supported,
otherwise not. This saves a few kb of code.
.IP "\s-1EV_COMMON\s0" 4
.IX Item "EV_COMMON"
By default, all watchers have a \f(CW\*(C`void *data\*(C'\fR member. By redefining
this macro to a something else you can include more and other types of
members. You have to define it each time you include one of the files,
though, and it must be identical each time.
.Sp
For example, the perl \s-1EV\s0 module uses something like this:
.Sp
.Vb 3
\&  #define EV_COMMON                       \e
\&    SV *self; /* contains this struct */  \e
\&    SV *cb_sv, *fh /* note no trailing ";" */
.Ve
.IP "\s-1EV_CB_DECLARE\s0 (type)" 4
.IX Item "EV_CB_DECLARE (type)"
.PD 0
.IP "\s-1EV_CB_INVOKE\s0 (watcher, revents)" 4
.IX Item "EV_CB_INVOKE (watcher, revents)"
.IP "ev_set_cb (ev, cb)" 4
.IX Item "ev_set_cb (ev, cb)"
.PD
Can be used to change the callback member declaration in each watcher,
and the way callbacks are invoked and set. Must expand to a struct member
definition and a statement, respectively. See the \fIev.v\fR header file for
their default definitions. One possible use for overriding these is to
avoid the \f(CW\*(C`struct ev_loop *\*(C'\fR as first argument in all cases, or to use
method calls instead of plain function calls in \*(C+.
.Sh "\s-1EXAMPLES\s0"
.IX Subsection "EXAMPLES"
For a real-world example of a program the includes libev
verbatim, you can have a look at the \s-1EV\s0 perl module
(<http://software.schmorp.de/pkg/EV.html>). It has the libev files in
the \fIlibev/\fR subdirectory and includes them in the \fI\s-1EV/EVAPI\s0.h\fR (public
interface) and \fI\s-1EV\s0.xs\fR (implementation) files. Only the \fI\s-1EV\s0.xs\fR file
will be compiled. It is pretty complex because it provides its own header
file.
.Sp
The usage in rxvt-unicode is simpler. It has a \fIev_cpp.h\fR header file
that everybody includes and which overrides some autoconf choices:
.Sp
.Vb 4
\&  #define EV_USE_POLL 0
\&  #define EV_MULTIPLICITY 0
\&  #define EV_PERIODICS 0
\&  #define EV_CONFIG_H <config.h>
.Ve
.Sp
.Vb 1
\&  #include "ev++.h"
.Ve
.Sp
And a \fIev_cpp.C\fR implementation file that contains libev proper and is compiled:
.Sp
.Vb 2
\&  #include "ev_cpp.h"
\&  #include "ev.c"
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Marc Lehmann <libev@schmorp.de>.
